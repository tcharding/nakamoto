//! Events generated by the peer-to-peer system.
use std::sync::{Arc, Mutex};
use std::time;

use crossbeam_channel as chan;

pub use chan::RecvTimeoutError;

/// An event publish/subscribe channel.
pub struct Broadcast<E, T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
    broadcast: Box<dyn FnMut(E, &Emitter<T>) + Send + Sync>,
}

impl<E, T: Clone> Broadcast<E, T> {
    /// Broadcast an event to all subscribers.
    pub fn broadcast(&mut self, event: E) {
        (self.broadcast)(
            event,
            &Emitter {
                subscribers: self.subscribers.clone(),
            },
        );
    }
}

/// Publishes an event to all subscribers.
pub struct Emitter<T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
}

impl<T: Clone> Emitter<T> {
    /// Publish an event to all subscribers.
    pub fn emit(&self, event: T) {
        self.subscribers
            .lock()
            .unwrap()
            .retain(|s| s.try_send(event.clone()).is_ok());
    }
}

/// An event subscriber.
#[derive(Clone)]
pub struct Subscriber<T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
}

impl<T> Subscriber<T> {
    /// Add a subscription to receive broadcast events.
    pub fn subscribe(&self) -> chan::Receiver<T> {
        let (sender, receiver) = chan::unbounded();
        let mut subs = self.subscribers.lock().unwrap();
        subs.push(sender);

        receiver
    }
}

/// Create a new broadcast channel.
pub fn broadcast<E, T>(
    pipe: impl FnMut(E, &Emitter<T>) + Send + Sync + 'static,
) -> (Broadcast<E, T>, Subscriber<T>) {
    let subscribers = Arc::new(Mutex::new(Vec::new()));
    (
        Broadcast {
            subscribers: subscribers.clone(),
            broadcast: Box::new(pipe),
        },
        Subscriber { subscribers },
    )
}

/// Listen to an event feed, and wait for the given function to return something,
/// or timeout if the specified amount of time has elapsed.
pub fn wait<E, F, T>(
    events: &chan::Receiver<E>,
    mut f: F,
    timeout: time::Duration,
) -> Result<T, chan::RecvTimeoutError>
where
    F: FnMut(E) -> Option<T>,
{
    let start = time::Instant::now();

    loop {
        if let Some(timeout) = timeout.checked_sub(start.elapsed()) {
            match events.recv_timeout(timeout) {
                Ok(event) => {
                    if let Some(t) = f(event) {
                        return Ok(t);
                    }
                }
                Err(err @ chan::RecvTimeoutError::Disconnected) => {
                    return Err(err);
                }
                Err(chan::RecvTimeoutError::Timeout) => {
                    // Keep trying until our timeout reaches zero.
                    continue;
                }
            }
        } else {
            return Err(chan::RecvTimeoutError::Timeout);
        }
    }
}
