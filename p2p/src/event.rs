//! Events generated by the peer-to-peer system.
use std::net;
use std::sync::{Arc, Mutex};
use std::time;

use bitcoin::network::message::NetworkMessage;
use crossbeam_channel as chan;

use crate::protocol::PeerId;
use crate::protocol::{addrmgr, cbfmgr, connmgr, invmgr, peermgr, syncmgr};

pub use chan::RecvTimeoutError;

/// A peer-to-peer event.
#[derive(Debug, Clone)]
pub enum Event {
    /// The node is now listening for incoming connections.
    Listening(net::SocketAddr),
    /// Received a message from a peer.
    Received(PeerId, NetworkMessage),
    /// An address manager event.
    AddrManager(addrmgr::Event),
    /// A sync manager event.
    SyncManager(syncmgr::Event),
    /// A connection manager event.
    ConnManager(connmgr::Event),
    /// A peer manager event.
    PeerManager(peermgr::Event),
    /// A CBF manager event.
    FilterManager(cbfmgr::Event),
    /// An inventory manager event.
    InventoryManager(invmgr::Event),
}

/// Any type that is able to publish events.
pub trait Publisher: Send + Sync {
    /// Publish an event.
    fn publish(&self, event: Event);
}

/// An event publisher.
pub struct Broadcast<E, T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
    filter: Box<dyn Fn(E) -> Option<T> + Send + Sync>,
}

impl<E, T: Clone> Broadcast<E, T> {
    /// Broadcast an event to all subscribers.
    pub fn broadcast(&self, event: E) {
        let mut subs = self.subscribers.lock().unwrap();

        if let Some(msg) = (self.filter)(event) {
            subs.retain(|s| s.try_send(msg.clone()).is_ok());
        }
    }
}

impl<T: Clone + Send + Sync> Publisher for Broadcast<Event, T> {
    /// Publish a message to all subscribers.
    fn publish(&self, event: Event) {
        self.broadcast(event)
    }
}

/// An event subscriber.
#[derive(Clone)]
pub struct Subscriber<T> {
    subscribers: Arc<Mutex<Vec<chan::Sender<T>>>>,
}

impl<T> Subscriber<T> {
    /// Add a subscription to receive broadcast events.
    pub fn subscribe(&self) -> chan::Receiver<T> {
        let (sender, receiver) = chan::unbounded();
        let mut subs = self.subscribers.lock().unwrap();
        subs.push(sender);

        receiver
    }
}

/// Create a new broadcast channel.
pub fn broadcast<E, T>(
    filter: impl Fn(E) -> Option<T> + Send + Sync + 'static,
) -> (Broadcast<E, T>, Subscriber<T>) {
    let subscribers = Arc::new(Mutex::new(Vec::new()));
    (
        Broadcast {
            subscribers: subscribers.clone(),
            filter: Box::new(filter),
        },
        Subscriber { subscribers },
    )
}

/// Listen to an event feed, and wait for the given function to return something,
/// or timeout if the specified amount of time has elapsed.
pub fn wait<F, T>(
    events: &chan::Receiver<Event>,
    mut f: F,
    timeout: time::Duration,
) -> Result<T, chan::RecvTimeoutError>
where
    F: FnMut(Event) -> Option<T>,
{
    let start = time::Instant::now();

    loop {
        if let Some(timeout) = timeout.checked_sub(start.elapsed()) {
            match events.recv_timeout(timeout) {
                Ok(event) => {
                    if let Some(t) = f(event) {
                        return Ok(t);
                    }
                }
                Err(err @ chan::RecvTimeoutError::Disconnected) => {
                    return Err(err);
                }
                Err(chan::RecvTimeoutError::Timeout) => {
                    // Keep trying until our timeout reaches zero.
                    continue;
                }
            }
        } else {
            return Err(chan::RecvTimeoutError::Timeout);
        }
    }
}
